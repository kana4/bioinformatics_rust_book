<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bioinformatics in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_1/1_0_Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_1/1_1_Background.html"><strong aria-hidden="true">1.1.</strong> Background</a></li><li class="chapter-item expanded "><a href="Chapter_1/1_2_Setup.html"><strong aria-hidden="true">1.2.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_2/2_0_Ready_Go.html"><strong aria-hidden="true">2.</strong> Ready Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_2/2_1_Add_Subtract_Multiply_Divide.html"><strong aria-hidden="true">2.1.</strong> Add, Subtract, Multiply, Divide</a></li><li class="chapter-item expanded "><a href="Chapter_2/2_2_Print_Numbers.html"><strong aria-hidden="true">2.2.</strong> Print Numbers</a></li><li class="chapter-item expanded "><a href="Chapter_2/2_3_Comparing_Printing_Strings.html"><strong aria-hidden="true">2.3.</strong> Comparing Printing Strings</a></li><li class="chapter-item expanded "><a href="Chapter_2/2_4_Level_Cleared.html"><strong aria-hidden="true">2.4.</strong> Level Cleared!</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_3/3_0_Vectors.html"><strong aria-hidden="true">3.</strong> Vectors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_3/3_1_Print_Vectors.html"><strong aria-hidden="true">3.1.</strong> Print Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_3/3_2_Dot_Notation.html"><strong aria-hidden="true">3.2.</strong> Dot Notation</a></li><li class="chapter-item expanded "><a href="Chapter_3/3_3_Notes_On_Vectors.html"><strong aria-hidden="true">3.3.</strong> Notes on Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_3/3_4_For_Loops.html"><strong aria-hidden="true">3.4.</strong> For Loops</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_4/4_0_References.html"><strong aria-hidden="true">4.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_4/4_1_Ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="Chapter_4/4_2_Notes.html"><strong aria-hidden="true">4.2.</strong> Chapter 4 Notes</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_5/5_0_Characters.html"><strong aria-hidden="true">5.</strong> Characters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_5/5_1_Biological_Sequencing_Data.html"><strong aria-hidden="true">5.1.</strong> Biological Sequencing Data</a></li><li class="chapter-item expanded "><a href="Chapter_5/5_2_Biological_Vector.html"><strong aria-hidden="true">5.2.</strong> Biological Vector</a></li><li class="chapter-item expanded "><a href="Chapter_5/5_3_Integer_Overflow.html"><strong aria-hidden="true">5.3.</strong> Integer Overflow</a></li><li class="chapter-item expanded "><a href="Chapter_5/5_4_Check_Sequence.html"><strong aria-hidden="true">5.4.</strong> Check Sequence</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_6/6_0_Biological_File_Types.html"><strong aria-hidden="true">6.</strong> Biological File Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_6/6_1_vcf.html"><strong aria-hidden="true">6.1.</strong> VCF</a></li><li class="chapter-item expanded "><a href="Chapter_6/6_2_sam_bam.html"><strong aria-hidden="true">6.2.</strong> SAM and BAM</a></li></ol></li><li class="chapter-item expanded "><a href="Chapter_7_Iteration.html"><strong aria-hidden="true">7.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="Chapter_8/8_0_Images.html"><strong aria-hidden="true">8.</strong> Images</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Chapter_8/8_1_Image_Background.html"><strong aria-hidden="true">8.1.</strong> Image Background</a></li><li class="chapter-item expanded "><a href="Chapter_8/8_2_Sequence_To_Image.html"><strong aria-hidden="true">8.2.</strong> Sequence To Image</a></li><li class="chapter-item expanded "><a href="Chapter_8/8_3_Colored_Block.html"><strong aria-hidden="true">8.3.</strong> Colored Block</a></li><li class="chapter-item expanded "><a href="Chapter_8/8_4_Magnify_Images.html"><strong aria-hidden="true">8.4.</strong> Magnify Images</a></li></ol></li><li class="chapter-item expanded "><a href="Index/Index.html"><strong aria-hidden="true">9.</strong> Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Index/Continuous_Integration.html"><strong aria-hidden="true">9.1.</strong> Continuous Integration</a></li><li class="chapter-item expanded "><a href="Index/Endianness.html"><strong aria-hidden="true">9.2.</strong> Endianness</a></li><li class="chapter-item expanded "><a href="Index/Ascii_Code_Table.html"><strong aria-hidden="true">9.3.</strong> ASCII Code Table</a></li><li class="chapter-item expanded "><a href="Index/Semicolons.html"><strong aria-hidden="true">9.4.</strong> Semicolons</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Bioinformatics in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="Chapter_1/../img/amaryllis.jpg" alt="amaryllis" />
<em>Amaryllis hybrid, London Horticulture Society</em></p>
<p>Hello user! You've found the book of bioinformatics in Rust. If you're a total beginner to anything bioinformatics, Rust, or programming, then this is the book for you. I hope it captures your interest like biology captured mine!</p>
<p>If you want to reach me or have something you want added to the book, find me on <a href="https://github.com/kana4">github</a> or let me know <a href="Chapter_1/keybase.io/kana4">here</a>!</p>
<h1 id="background-binary-vs-library"><a class="header" href="#background-binary-vs-library">Background: Binary vs Library</a></h1>
<p>When we get a program, we click it, it opens, and we'll be able to do stuff. We'll have to choose the program based on our operating system.</p>
<p>The program we're downloading is most likely a <a href="https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Compiled_Programs">compiled</a> program. This program is <a href="https://en.wikipedia.org/wiki/Executable">executable</a> by the specific operating system we're using. The program has system-specific operations amalgamated together so the computer can do the things we want it to in an efficient manner.  In Rust, we create these kinds of programs by telling Rust to make a binary file (e.g. an executable). You may have heard this word before on Windows as the <a href="https://en.wikipedia.org/wiki/.exe">.exe</a> file type  or just plain no file extension in Ubuntu or Linux. In Rust, we can make all of these file types really easily!</p>
<p>Binaries always have a main function, written <code>fn main(){}</code>. This main function is the <a href="https://en.wikipedia.org/wiki/Steve_Jobs">Steve Jobs</a> (or <a href="https://en.wikipedia.org/wiki/Steve_Wozniak">Woz</a>) of all things in our binary. Everything that will actually be done is in the main function, with other  functions, definitions, etc. being sourced from everywhere else. We build binaries by typing <code>cargo build --bin</code>.</p>
<p>The other kind of thing we make in Rust is a library. While we also build a library with <code>cargo build --lib</code>, a library does not have a program that we can just run like what we would imagine. This is because a library's purpose is to be a bunch of small, reusable pieces of code that we can use to make an executable, but aren't really useful to our users. As an analogy, a library is like a tool shed and the binary a car that the user drives.</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>We'll be building binaries in this book on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=730c462d7171d22098403822416c698d">Rust playground</a>, a website where everything is already set up for us; ! Each of the exercises will have a link to the playground with the exercise we're working on, it's that easy!</p>
<p><img src="Chapter_1/../img/playground_xkcd.png" alt="playground xkcd" /></p>
<p><em>Getting started in Rust is as simple as opening a webpage!</em></p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8326f6350e307f3184ca0008ff66a3ec">playground</a></p>
<h1 id="ready-go"><a class="header" href="#ready-go">Ready Go</a></h1>
<p>Instead of going into a lot of detail, let's just start doing things!</p>
<pre><code>fn main(){

    // This is a comment in a function! 

}

</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=172d9e4fa342625a6ea2acc8e74ad232">playground</a></p>
<p>Comments don't do anything in code because of the two // marks before the text and can be put anywhere</p>
<p>We need comments to let people know what we're doing in between code, and we'll use them to talk to you throughout code tutorials</p>
<p>Our comment is in the <code>main</code> function, e.g. <code>fn main(){}</code>, specifying we're making a binary.</p>
<p><img src="Chapter_2/../img/hsa_nasa.jpg" alt="hsa nasa" />
<em>Electron density projection of human serum albumin protein taken by NASA. Even complicated biological things are made of smaller, simpler things!</em> </p>
<h1 id="add-subtract-multiply-divide"><a class="header" href="#add-subtract-multiply-divide">Add, Subtract, Multiply, Divide</a></h1>
<pre><code>fn main(){

    // Make a variable a that holds 1
    let a = 1;

    // Make a variable b that holds 2
    let b = 2;

    // Add them together to get c
    let c = a + b;

    // Multiple by 3!
    let d = c * 3;
    
    // Divide by 3!
    let e = d / 3;

    // The variable e holds 3
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a31f2eadc4a15117a95e13fb5b271fc3">playground</a></p>
<p>Each line is separated by a semicolon, letting our program know to keep going. If there isn't a semicolon at the end of a line, return the result of that line. For more information: <a href="Chapter_2/./Index/Semicolons.html">Semicolons</a></p>
<h1 id="print-numbers"><a class="header" href="#print-numbers">Print Numbers</a></h1>
<p>Let's print something!</p>
<pre><code>fn main(){
    println!(&quot;42&quot;)
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=85ae37adbe96892255eab588c99912fe">playground</a></p>
<p>Well that was pretty easy, we didn't even need the semicolon because we end the main function after printing. Now instead of printing directly, let's try printing something in a variable.</p>
<pre><code>fn main(){
    // Make a variable x that holds 42
    let x = 42;

    println!(&quot;{}&quot;, x)

}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cbf3b19f6d773542f6913edcf48bb5db">playground</a></p>
<p>Now that we have a variable, <code>println!</code> takes two parts, the first is formatting the print, while the second part is the variable to print. the quotes surround everything that will be printed, in our case, <code>{}</code> which is always the input variable. In plain English, we've stated to print only the variable. We probably want to other things than just deal with numbers though, and we can do that by adding in the quotation marks:</p>
<pre><code>fn main(){
    // Make a variable x that holds 42
    let x = 42;

    println!(&quot;The magic number x is {}!&quot;, x)

    // Prints &quot;The magic number x is 42!&quot;
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=eaee565b026b99fc808e6245da640cc0">playground</a></p>
<h1 id="comparing-printing-strings"><a class="header" href="#comparing-printing-strings">Comparing Printing Strings</a></h1>
<p>In <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreted</a> languages, doing things is really short and succinct. Let's go with a classic: printing &quot;Hello World!&quot;.</p>
<pre><code># In Python: 

thing = &quot;Hello World!&quot;

print(thing)
</code></pre>
<pre><code># In R:
thing = &quot;Hello World!&quot;

print(thing)
</code></pre>
<pre><code>// In Rust:

fn main(){

    let thing = &quot;Hello World!&quot;;

    println!(&quot;{}&quot;, thing);
    
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b7a9925991302bdd3802fa2a25c89d0e">playground</a></p>
<p>Why is it so much longer in Rust? With great power comes having to be specific! Let's break it down based on what we learned so far.</p>
<p>We're building a binary, which is why we have the main function, <code>fn main(){}</code>. </p>
<p>Inside the main function, we create a variable <code>thing</code> that stores <code>&quot;Hello World!&quot;</code> We put the <code>thing</code> variable into <code>println!</code>, where <code>&quot;{}&quot;</code> is just our variable, and the second input is the actual variable to be printed. We could also print something more fun like:</p>
<p><code>Our variable contains: Hello World!</code> </p>
<p>by typing:</p>
<p><code>println!(&quot;Our variable contains: {}&quot;, thing);</code></p>
<h1 id="level-cleared"><a class="header" href="#level-cleared">Level Cleared!</a></h1>
<p>Congratulations, you cleared level 2! It was a bunch of sections, but we learned some programming building blocks that we'll continue to use for the rest of our career. Time to take a break!</p>
<p><img src="Chapter_2/../img/FMRI.gif" alt="fmri gif" /></p>
<p><em>Functional MRI of a resting mouse brain, Zuckerman Institute</em>
<a href="https://pubmed.ncbi.nlm.nih.gov/27974609/">Ma, Hillman et al.</a></p>
<h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>We made a string in the prior section, so let's make it's simpler cousin, the vector!</p>
<pre><code>fn main(){
    let thing_of_things = vec![1,2,3,4];
}
</code></pre>
<p>What <em>is</em> a vector exactly? A <a href="https://doc.rust-lang.org/rust-by-example/std/vec.html">vector</a> in Rust is a sequence of things, in our case the numbers 1,2,3,4 one after the other. This is also referred to as a <a href="https://en.wikipedia.org/wiki/Composite_data_type">composite</a> type because a vector is made of multiple smaller things. We could also make the vector with the following:</p>
<pre><code>fn main(){
    let thing1 = 1;
    let thing2 = 2;
    let thing3 = 3;
    let thing4 = 4;

    let thing_of_things = vec![thing1,thing2,thing3,thing4];
}
</code></pre>
<h1 id="printing-vectors-and-debug-mode"><a class="header" href="#printing-vectors-and-debug-mode">Printing Vectors and Debug Mode</a></h1>
<p>If you look closely, we didn't print the vector just yet, for that we need something called <code>debug</code>!</p>
<p>Debug is something new if you're coming from other languages like R or Python, and it's something that we don't really need to know how it works, so we'll just leave it at: <em>We neeeeeeed it!</em> At least for vectors.</p>
<pre><code>fn main(){
    let thing_of_things = vec![1,2,3,4];
    println!(&quot;{:?}&quot;,thing_of_things)
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b94f6fadd0cb4b684b29f22803547f0d">playground</a></p>
<p>Can you spot the debug notation? It's the <code>:?</code> inside the <code>{}</code>! Rust is super smart, if we didn't have the debug and just wrote <code>println!(&quot;{}&quot;,thing_of_things)</code> like in our prior examples, we'd get an error like this:</p>
<p><code>the trait std::fmt::Display is not implemented</code></p>
<p>But we'd also get this:</p>
<p><code>in format strings you may be able to use {:?} (or {:#?} for pretty-print) instead</code></p>
<p>The first option is exactly what we needed, which leads us to the golden rule: figure out the output Rust gives us. Rust is pretty smart, it'll probably give us some useful clues (and in this case the exact fix) to what to do if we get an error! It's a safe troubleshooting default if we get an error when printing to try add in the <code>:?</code>.</p>
<h1 id="dot-notation"><a class="header" href="#dot-notation">Dot Notation</a></h1>
<p>In Rust and a few other programming languages, we can use <a href="https://en.wikipedia.org/wiki/Property_(programming)#Dot_notation">dot notation</a>.
Dot notation is used when we have a thing and we want to do something with it. In pseudo programming English if I wanted to say: </p>
<p>&quot;cut apple&quot;</p>
<p>With dot notation it would look something like: </p>
<p><code>apple.cut();</code></p>
<p>where we have an apple and we want to cut it. Let's use dot notation with a vector!</p>
<pre><code>fn main(){
    
    // Make a vector holding the numbers 1,2,3,4

    let vector = vec![1,2,3,4];

    // Use dot notation with len(), a function to get the length of a vector

    let length_of_vector = vector.len();

    // Print the value stored in length_of_vector, which is the length of the vector

    println!(&quot;{}&quot;,length_of_vector)

}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=270b25fb22fee3383a695eff2bb33e3f">playground</a></p>
<p>Congrats! We've not only used our first dot notation, our first function! It doesn't seem like it now, but <code>len()</code> is a workhorse for Rust programmers of all levels. Dot notation will help us be more concise and expressive in our programming. We want our programs (as) short and sweet (as possible).</p>
<p><img src="Chapter_3/../img/Margaret_Hamilton.jpg" alt="Margaret Hamilton" /></p>
<p><em><a href="https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer)">Margaret Hamilton</a> and software for Apollo. Dot notation saves us space (no pun intended). Thanks to early researchers, the world runs on computers! Credits: Wikipedia</em></p>
<h1 id="notes-on-vectors"><a class="header" href="#notes-on-vectors">Notes on Vectors</a></h1>
<p>Vectors are used in Python and R as one of the main objects and it's no different in Rust, but Rust also has many alternatives that can make things faster and more efficient. If you're doing millions of calculations, any small bit counts! This is one of the great things about Rust: where other languages are limited, Rust doesn't have limits. We'll cover some of the features that make Rust much more powerful than the interpreted languages in the next chapter!</p>
<p><img src="Chapter_3/../img/ferris_love.jpg" alt="Ferris Hearts" /></p>
<p><em>Rustaceans are super helpful and encouraging, joining the chats is one of the best ways to learn! Image credits: <a href="https://rustacean.net">Karen Rustad Tölva</a></em></p>
<p>Rust chats:</p>
<p><a href="https://discord.com/invite/rust">Rust Discord!</a></p>
<p><a href="https://users.rust-lang.org">Rust Language Forums</a></p>
<h1 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h1>
<p>We now know that vectors are made of smaller pieces of data; what if we wanted to do something for each part (element) of our vector?</p>
<p>Each language has multiple ways to do something for each element of our vector. In any language, we could write a <code>for</code> or a <code>while</code> loop:</p>
<pre><code># Python

vector = [1,2,3,4]
for element in vector:
    print(element)

</code></pre>
<pre><code># R

vector = c(1,2,3,4)
for (element in 1:length(vector)) {
    print(element)
}

</code></pre>
<pre><code>// Rust

fn main(){
    let vector = vec![1,2,3,4];
    for element in vector {
        println!(&quot;{}&quot;, element);
    }
}

</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5eac305bb88b46f33e9ba4d264f3d349">playground</a></p>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<p><em>Warning: Difficult Section!</em>
<em>(Don't worry, we aren't going to use this yet)</em></p>
<p>References are one way to make code super efficient. The general idea is that we memorized some data, and instead of re-memorizing it we refer to it. In Python or R, we just have the data in a variable and that variable is copied over and over again whenever we want to use it. In most cases, we could have just made and memorized the data once and referred to it in the rest of the program.</p>
<p>In a metaphoric example, Rust makes a book (our data), stores it on a shelf, and whenever someone wants some information from the book, we let them know where the book is on the shelf rather than making a copy of the whole book. Making copies of a book in the real world is expensive; the same holds true in computation. On the other hand, our new method not only saves us the time of copying a whole book, but means we don't have to walk to the shelf ourselves, and lets us direct a revolving door of people that want books.</p>
<h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Ownership and references are some of the defining and central ideas of the Rust language. Who else could explain it better than the language developers themselves?</p>
<p>The Rust Language Book:</p>
<p><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References</a></p>
<p><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Ownership</a></p>
<p>A visualization we really liked is from <a href="https://github.com/rustviz/rustviz">Rustviz</a>:</p>
<p><img src="Chapter_4/../img/rustviz.png" alt="Rustviz" />
<em>Simple example of visualization of ownership and references.</em></p>
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<p>We want to focus on doing things in bioinformatics, so from here we're going to link background information in the <a href="https://doc.rust-lang.org/book/">Rust books</a> or this book's index for bioinformatics background. Next, making characters into numbers!</p>
<p><img src="Chapter_4/../img/binary_heart.jpg" alt="xkcd_heart" /></p>
<p><em><a href="https://xkcd.com/99/">binary &lt;3</a> by xkcd</em></p>
<h1 id="characters"><a class="header" href="#characters">Characters</a></h1>
<p>Before we get into biological data, we first need to be able to give the computer knowledge of what an alphabet, or even a character is. Computers can only understand numbers, so how do we tell it we want alphabet characters? One way to do that is to choose a number for each character in some systematic way. One method could be instead of ABC we save 123 if we're using the location in the alphabet as our integer. Since we know the alphabet, we can store numbers and still know what the numbers are supposed to say, and convert back and forth between numbers and characters.</p>
<p>Most commonly, this is done with <a href="https://en.wikipedia.org/wiki/Byte">bytes</a>. When your internet company's talking about speeds, megabits are different from megabytes (8 bits to a byte)! Each byte most commonly represents a character like A or T, but instead of A or T, it's a number. Since each number represents a character, we can write a word as a vector of numbers. In our first example of 'ABC', it would just be <code>vec![1,2,3]</code>.</p>
<p>In practice, 'A' isn't stored as 1, but as '65' in the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII alphabet</a> and '41' in <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. This is to be useful to users and computers around the world; UTF-8 has a ton of stuff, even <a href="https://unicode.org/emoji/charts/full-emoji-list.html">emojis</a>!</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>I really enjoyed Stanford's <a href="https://web.stanford.edu/class/cs101/bits-bytes.html">bits and bytes</a> section!</p>
<p><a href="Chapter_5/../Index/Ascii_Code_Table.html">ASCII Alphabet Table</a></p>
<h1 id="biological-sequences"><a class="header" href="#biological-sequences">Biological Sequences</a></h1>
<p>In this chapter, we're going to start working with biological data, finally!</p>
<p>DNA classically contains the four bases ACTG, whereas RNA includes ACUG. In sequencing data, we usually encode RNA data as ACTG for ease of use, and notate that the file is RNA data. We also commonly include 'N', where we're unsure of what base goes there but we think there's something there. </p>
<pre><code>fn main(){
    // DNA vector, RNA is commonly encoded the same way
    let dna = b&quot;ACTG&quot;.to_vec();
    // DNA vector containing a base we're unsure of, but think it's present.
    let dna_with_n = b&quot;ACTNG&quot;.to_vec();
</code></pre>
<p><img src="Chapter_5/../img/histone_octamer_small.jpg" alt="2mm Crystallized Histone Octamer" /></p>
<p><em><a href="https://archive.org/details/MSFC-9807365">Crystallized Histone Octamer (2mm)</a> DNA sequences are wrapped around proteins called <a href="https://en.wikipedia.org/wiki/Histone">histones</a>. If put under the right pressure and temperature, these proteins can be made into crystals! Picture Credits: NASA, Dan Carter of New Century Pharmaceuticals</em></p>
<h1 id="biological-vector"><a class="header" href="#biological-vector">Biological Vector</a></h1>
<p>In the previous section, we created a biological sequence and made it into a vector with <code>to_vec()</code>. </p>
<p>We've created a vector of ACTG and that the vector doesn't hold characters, but bytes. Now that the computer has an idea of a biological sequence, we can start working with our biological data just like any other numeric vector! This includes things that we're more familiar with from math, and in this section we'll do something that we can only do once we've made our characters into numbers: find the sum! What's the sum of 'ACTG'? Let's find out!</p>
<pre><code>fn main(){

    let dna = b&quot;ACT&quot;.to_vec();

    let mut sum = 0;

    for base in dna {
        sum += base;
    }

    println!(&quot;{}&quot;, sum);

    // Prints 216
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=343748b7922270bccc2ec0cfa84d245c">Playground</a></p>
<h2 id="links"><a class="header" href="#links">Links:</a></h2>
<p>The <code>mut</code> keyword: a <a href="https://doc.rust-lang.org/rust-by-example/scope/borrow/mut.html">mutable</a> variable. </p>
<p><code>+=</code> notation: <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Adding</a> to a variable.</p>
<p><code>-=</code> notation: <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Subtracting</a> to a variable.</p>
<p>Definitions from the Rust language appendix:</p>
<pre><code>+= Arithmetic addition and assignment, AddAssign

-= Arithmetic subtraction and assignment, SubAssign
</code></pre>
<p><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Rust Operators</a></p>
<p>Writing our first <a href="https://doc.rust-lang.org/rust-by-example/flow_control/for.html">For loop: Rust by Example</a></p>
<h1 id="integer-overflow"><a class="header" href="#integer-overflow">Integer Overflow</a></h1>
<p>In the last section, we summed the elements in a vector. If we did this directly in real programs, Rust would probably panic and say something along the lines of <code>integer overflow</code>, depending on our DNA sequence. This is because unsigned 8-bit integers can only hold a maximum value of 256, so if our sum was larger than 256, Rust wouldn't know what to do and panic. For example:</p>
<pre><code>fn main(){
    
    // Changed dna sequence from ACT to ACTG
    
    let dna = b&quot;ACTG&quot;.to_vec();

    let mut sum = 0;

    for base in dna {
        sum += base;
    }

    println!(&quot;{}&quot;, sum);

    // Rust returns an integer overflow error, sum is greater than 256

}
</code></pre>
<p>Don't worry though, we can fix that easily by converting our <code>sum</code> variable into an <a href="https://doc.rust-lang.org/std/primitive.u64.html">unsigned 64-bit integer</a> (u64). The max number for this integer type: 18,446,744,073,709,551,615! This also means we need to change each element of the vector to a u64 (using the <code>as</code> keyword), as we can't add different types of integers.</p>
<pre><code>fn main(){

    let dna = b&quot;ACTG&quot;.to_vec();

    // We tell Rust that we want sum to equal 0, but 0 as a u64

    let mut sum = 0u64;

    for base in dna {
        
        // convert each element (base) to u64 to add to sum (also u64)

        sum += base as u64; 

    }

    println!(&quot;{}&quot;, sum);
    
    // Prints 287
}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b0c5cfb4478657b0bbdb1a19c3f37f41">playground</a></p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p><a href="https://doc.rust-lang.org/reference/types/numeric.html">Numeric types</a></p>
<p>Converting between <a href="https://doc.rust-lang.org/rust-by-example/types/cast.html">('casting')</a> numeric types with <code>as</code></p>
<h1 id="check-sequence"><a class="header" href="#check-sequence">Check Sequence</a></h1>
<p>Calculating the sum of a sequence is pretty cool, but probably isn't very useful to us in a direct sense. Let's do something with a little more direct application: checking if our sequence is a <a href="https://www.merriam-webster.com/dictionary/homopolymer">homopolymer</a>!</p>
<p>There's a few steps we're going to do here:</p>
<ul> Store the first element of our sequence in a variable to compare to the other elements </ul>
<ul> Create a separate vector where each element is a boolean true/false. Rust gives us a really nice macro (vec![]) to make an empty vector. </ul>
<ul> For each element in our sequence, check if the element is the same as the first element and push the result into our boolean vector. </ul>
<ul> Print our boolean vector to see our results! </ul>
<pre><code>fn main(){

    let vector = b&quot;AAAAA&quot;.to_vec();
    
    let first_element = vector[0];
        
    let mut boolean_vector: Vec&lt;bool&gt; = vec![];

    // For each element, true or false: is the same as the first element    
    for element in vector {
        boolean_vector.push(first_element == element)
    }

    println!(&quot;{:?}&quot;, boolean_vector);

}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1bf1cb00cdfce69f3765253711c55c55">playground</a></p>
<p><em>Note:</em> There's always more than one way to do things, can you think of other ways to test whether a sequence is a homopolymer?</p>
<h1 id="biological-file-types"><a class="header" href="#biological-file-types">Biological File Types</a></h1>
<p>Biological data most commonly has a header with a description of the data followed by the data itself. If a variant analysis was done, we might get back a variant call file (<a href="https://en.wikipedia.org/wiki/Variant_Call_Format">VCF</a>), which will annotate variants from a genome reference. Sequencing Alignment Mapping (<a href="https://en.wikipedia.org/wiki/SAM_(file_format)">SAM</a>) files are usually a lot larger and contain all the sequencing data aligned to our genome reference. <a href="https://en.wikipedia.org/wiki/FASTA_format">Fasta</a> files (not really short for anything) are the simplest of all; they only contain sequences and descriptions of the sequences. We'll take a quick look at these file types so we know what we could be working with.</p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p><a href="http://samtools.github.io/hts-specs/">Official File Format Specifications</a>. Includes VCF, SAM, CRAM, BAM, BCF, CSI, Tabix, crypt4gh, htsget, and Refget</p>
<h1 id="vcf-file-format"><a class="header" href="#vcf-file-format">VCF File Format</a></h1>
<p>First, a quick look at what VCF data looks like:</p>
<pre><code>##fileformat=VCFv4.0
##fileDate=20100610 
##source=glfTools v3
##reference=1000GenomesPilot-NCBI36 
##phasing=NA
##INFO=&lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Mapped Reads&quot;&gt;
##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&gt;
##INFO=&lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&gt;
##INFO=&lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&gt;
##FILTER=&lt;ID=NUYR,Description=&quot;Variant in non-unique Y region&quot;&gt;
(base) l@mbp Downloads % head -100 test.vcf
##fileformat=VCFv4.0
##fileDate=20100610 
##source=glfTools v3
##reference=1000GenomesPilot-NCBI36 
##phasing=NA
##INFO=&lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Mapped Reads&quot;&gt;
##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&gt;
##INFO=&lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&gt;
##INFO=&lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&gt;
##FILTER=&lt;ID=NUYR,Description=&quot;Variant in non-unique Y region&quot;&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;
##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype	Quality&quot;&gt;
##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Depth&quot;&gt;
##INFO=&lt;ID=AC,Number=.,Type=Integer,Description=&quot;Allele count in genotypes&quot;&gt;
##INFO=&lt;ID=AN,Number=1,Type=Integer,Description=&quot;Total number of alleles in called genotypes&quot;&gt;
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO
Y	2728456	rs2058276	T	C	32	.	AC=2;AN=2;DB;DP=182;H2;NS=65
Y	2734240	.	G	A	31	.	AC=1;AN=2;DP=196;NS=63
Y	2743242	.	C	T	25	.	AC=1;AN=2;DP=275;NS=66
Y	2746727	.	A	G	34	.	AC=2;AN=2;DP=179;NS=64
Y	2777970	.	T	A	67	.	AC=1;AN=2;DP=225;NS=67
Y	2782506	rs2075640	A	G	38	.	AC=1;AN=2;DB;DP=254;H2;NS=66
Y	2783755	.	G	A	51	.	AC=1;AN=2;DP=217;NS=67
Y	2788927	rs56004558	A	G	38	.	AC=1;AN=2;DB;DP=173;NS=60
Y	2813908	.	T	G	46	.	AC=1;AN=2;DP=188;NS=67
Y	2815679	.	T	C	30	.	AC=1;AN=2;DP=205;NS=64
Y	2816471	rs9785784	T	A	40	.	AC=1;AN=2;DB;DP=212;NS=64
Y	2841844	.	T	G	41	.	AC=1;AN=2;DP=176;NS=56
Y	2891375	.	T	C	29	.	AC=1;AN=2;DP=176;NS=61
Y	2899051	.	C	T	51	.	AC=1;AN=2;DP=206;NS=68
Y	2900301	.	G	A	54	.	AC=1;AN=2;DP=167;NS=65
Y	2923665	rs7892924	G	A	34	.	AC=1;AN=2;DB;DP=171;NS=63
Y	2944029	.	T	C	35	.	AC=1;AN=2;DP=244;NS=61
Y	2947824	rs9786184	A	C	39	.	AC=2;AN=2;DB;DP=206;NS=63
Y	2962839	rs9786562	C	T	33	.	AC=2;AN=2;DB;DP=185;NS=63
Y	2972385	rs9786491	C	T	29	.	AC=1;AN=2;DB;DP=160;NS=55
Y	3034782	.	A	C	40	.	AC=1;AN=2;DP=163;NS=64
Y	3094725	.	C	G	18	.	AC=1;AN=2;DP=179;NS=63
Y	3134753	.	A	T	42	.	AC=1;AN=2;DP=189;NS=65
Y	3144401	.	G	A	46	.	AC=1;AN=2;DP=169;NS=59
Y	3168773	.	C	T	43	.	AC=1;AN=2;DP=173;NS=64
Y	3537173	rs7067327	G	C	31	.	AC=2;AN=2;DB;DP=193;NS=64
Y	3751769	.	A	G	26	.	AC=1;AN=2;DP=173;NS=61
Y	3781790	.	T	A	55	.	AC=1;AN=2;DP=165;NS=59
Y	4176203	.	G	A	18	.	AC=1;AN=2;DP=166;NS=69
Y	4177733	.	A	G	40	.	AC=1;AN=2;DP=177;NS=61
Y	4305332	.	T	C	46	.	AC=1;AN=2;DP=174;NS=69

</code></pre>
<p>Even if we don't know about the file type, we can start to get an idea that the file has a header followed by a table-looking structure of the actual data. In VCF, each line in a header is denoted by <code>##</code>, whereas the column names are denoted by a single <code>#</code>. To summarize each column in the data:</p>
<ul>Chromosome: Which chromosome is the alteration on?</ul>
<ul>Position: What position on the chromosome is the alteration on?</ul>
<ul>ID: If this is a well known alteration, what's the ID?</ul>
<ul>Ref: What's the base in the genome reference?</ul>
<ul>Alt: What's the base altered to?</ul>
<ul>Quality: What's the quality related to the alteration or in a not-correct not-incorrect answer, how sure are we of the alteration?</ul>
<ul>Filter: Does the alteration pass a cutoff for quality, or in a not-correct not-incorrect answer, are we more sure or unsure of the alteration?</ul>
<ul>Info: Other information that we couldn't fit into the other columns</ul><h1 id="sam-and-bam-file-format"><a class="header" href="#sam-and-bam-file-format">Sam and Bam File Format</a></h1>
<p>What SAM data looks like:</p>
<pre><code>@SQ	SN:chr1	LN:249250621
@SQ	SN:chr2	LN:243199373
@SQ	SN:chr3	LN:198022430
@SQ	SN:chr4	LN:191154276
@SQ	SN:chr5	LN:180915260
@SQ	SN:chr6	LN:171115067
@SQ	SN:chr7	LN:159138663
@SQ	SN:chr8	LN:146364022
@SQ	SN:chr9	LN:141213431
@SQ	SN:chr10	LN:135534747
(base) l@mbp Downloads % head -400 out.sam
@SQ	SN:chr1	LN:249250621
@SQ	SN:chr2	LN:243199373
@SQ	SN:chr3	LN:198022430
@SQ	SN:chr4	LN:191154276
@SQ	SN:chr5	LN:180915260
@SQ	SN:chr6	LN:171115067
@SQ	SN:chr7	LN:159138663
@SQ	SN:chr8	LN:146364022
@SQ	SN:chr9	LN:141213431
@SQ	SN:chr10	LN:135534747
@SQ	SN:chr11	LN:135006516
@SQ	SN:chr12	LN:133851895
@SQ	SN:chr13	LN:115169878
@SQ	SN:chr14	LN:107349540
@SQ	SN:chr15	LN:102531392
@SQ	SN:chr16	LN:90354753
@SQ	SN:chr17	LN:81195210
@SQ	SN:chr18	LN:78077248
@SQ	SN:chr19	LN:59128983
@SQ	SN:chr20	LN:63025520
@SQ	SN:chr21	LN:48129895
@SQ	SN:chr22	LN:51304566
@SQ	SN:chrM	LN:16571
@SQ	SN:chrX	LN:155270560
@PG	ID:samtools	PN:samtools	VN:1.11	CL:samtools view -h -o out.sam wgEncodeUwRepliSeqBg02esG1bAlnRep1.bam
SOLEXA-1GA-2_2_FC20EMB:5:251:979:328	0	chr1	10145	25	36M	*	0	0	AACCCCTAACCCTAACCCTAACCCTAACCCTAAAChhhhHcWhhHTghcKA_ONhAAEEBZE?H?CBC?DA	NM:i:1	X1:i:1	MD:Z:33A2
SOLEXA-1GA-2_2_FC20EMB:5:102:214:278	0	chr1	10148	25	36M	*	0	0	CCCTAACCCTAACCCTAACCCTAACCCTAACCTAAhbfhhhXUYhT_ULZdLRTKNIMIKGLJCHFFJQJN	NM:i:0	X0:i:1	MD:Z:36
SOLEXA-1GA-2_2_FC20EMB:5:195:284:685	16	chr1	10149	25	36M	*	0	0	CCAAACACTAACCCTAACCCTAACCCTAACCTAAC&gt;&lt;&gt;B@&gt;?&gt;?D&gt;&gt;?B?D&gt;DBC?E@BDHAKCEKERLOO	NM:i:1	X1:i:1	MD:Z:29A3A2
SOLEXA-1GA-2_2_FC20EMB:5:35:583:827	0	chr1	10150	25	36M	*	0	0	CTAACCCTAAACCTAACCCTAACCCTAACCTAACChhW_X]MXNOHQQWMILHGIFMJGJLCFGGJAKIEH	NM:i:1	X1:i:1	MD:Z:10A24A0
SOLEXA-1GA-2_2_FC20EMB:5:248:130:724	0	chr1	10152	25	36M	*	0	0	AACCCTAACCCTAACCCCAACCCTAACCTAACCCThchPhc___cWS[VRObRXDTOUSJLXOA@LGFMC@	NM:i:1	X1:i:1	MD:Z:17C18
SOLEXA-1GA-2_2_FC20EMB:5:236:644:107	16	chr1	10154	25	36M	*	0	0	CCCTAACCCTAACCCTAACCCTAACCTAACCCTAAICF=A@BHGEGGDFLIKKYYGD^CahMaShfhNhhh	NM:i:0	X0:i:1	MD:Z:36
SOLEXA-1GA-2_2_FC20EMB:5:165:628:70	16	chr1	10155	25	36M	*	0	0	CCTAACCCTAACCCTAACCTTTACATAACCCTAAC&gt;D?BAEAA?E=JGGBK&gt;FKDGFJPVHSFTT\QQMch	NM:i:1	X1:i:1	MD:Z:11A2T1T19
SOLEXA-1GA-2_2_FC20EMB:5:108:485:455	16	chr1	10156	25	36M	*	0	0	CTAACCCTAACCCTAACCCTAACATAACCCTAACCCFVIUIIIbGPROGhRhhhIhhhhhhhhhhhhfhhh	NM:i:1	X1:i:1	MD:Z:12A23
SOLEXA-1GA-2_2_FC20EMB:5:240:501:237	0	chr1	10158	25	36M	*	0	0	AACCCTAACCCTAACCCTAACCTAACCCTAACCAThhhchg_ORNbX]RMZLREQMNTNFLDPMDDDEDKL	NM:i:1	X1:i:1	MD:Z:33A2
SOLEXA-1GA-2_2_FC20EMB:5:258:882:389	16	chr1	10215	25	36M	*	0	0	CTAACCCTAAACCTAACCCCTAACCCTAACCCTAAIMZO&gt;?EGDRRhhdXKVNRZKhhhhhhhNhhhhhhh	NM:i:1	X1:i:1	MD:Z:25A10
SOLEXA-1GA-2_2_FC20EMB:5:197:509:870	16	chr1	10216	25	36M	*	0	0	TAAACCGAACCCGAACCCCTAACCCTAACCCTAAA&lt;IJELC@SCUMY?R?D\UPW^@d]hWXN\hhhhhLh	NM:i:1	X1:i:1	MD:Z:23G5G2A3
SOLEXA-1GA-2_2_FC20EMB:5:160:880:612	0	chr1	10217	25	36M	*	0	0	AACCCTAACCCTAACTCCTAACCCTAACCCTAAAChhhNh\O[WUNYQKOWNSIIDNFOPHJHIAI@GDJG	NM:i:1	X1:i:1	MD:Z:15T19A0
SOLEXA-1GA-2_2_FC20EMB:5:249:922:808	16	chr1	10217	25	36M	*	0	0	AACACTAACCCCAACCCCTAACCCTAACCCTAAAChKWQRBhhB``Ah`hhhhhhhhhhhhhhhhhhhhhh	NM:i:1	X1:i:1	MD:Z:0A23C7A3
SOLEXA-1GA-2_2_FC20EMB:5:13:922:731	0	chr1	10236	25	36M	*	0	0	GACCCAAACCCTAAACCCTAAACCCTAAACCTAAChMhWZaPTSZHfUMMSOJTJEKLKELKKDJ&gt;JPCEI	NM:i:1	X1:i:1	MD:Z:0G4A22A7
SOLEXA-1GA-2_2_FC20EMB:5:62:877:892	16	chr1	10237	25	36M	*	0	0	ACCCCAACCCTACACCCTACACCCTAACCCTAACCCHLKEQGOUcCQ`GYdhF[hXhhhWhhhhhWhhhhh	NM:i:1	X1:i:1	MD:Z:16C6C7C4
SOLEXA-1GA-2_2_FC20EMB:5:172:417:550	16	chr1	10242	25	36M	*	0	0	AACCCTAAACCCTAAACCCTAACCCTAACCCTAACB@BA&gt;=EG&gt;B@CANEDBEKBMGRCMGVJTORShKhh	NM:i:0	X0:i:1	MD:Z:36
</code></pre>
<p>BAM data is the same as SAM only compressed and in binary form. When converted, it looks just like SAM data. Raw, it looks like this (using <code>hexdump</code>):</p>
<pre><code>0000000 42 41 4d 01 00 00 00 00 18 00 00 00 05 00 00 00
0000010 63 68 72 31 00 3d 43 db 0e 05 00 00 00 63 68 72
0000020 32 00 8d ed 7e 0e 05 00 00 00 63 68 72 33 00 1e
0000030 95 cd 0b 05 00 00 00 63 68 72 34 00 64 c8 64 0b
0000040 05 00 00 00 63 68 72 35 00 3c 8c c8 0a 05 00 00
0000050 00 63 68 72 36 00 3b 02 33 0a 05 00 00 00 63 68
0000060 72 37 00 67 43 7c 09 05 00 00 00 63 68 72 38 00
0000070 76 56 b9 08 05 00 00 00 63 68 72 39 00 f7 be 6a
0000080 08 06 00 00 00 63 68 72 31 30 00 9b 18 14 08 06
0000090 00 00 00 63 68 72 31 31 00 34 09 0c 08 06 00 00
</code></pre>
<h1 id="iteration"><a class="header" href="#iteration">Iteration</a></h1>
<h1 id="images"><a class="header" href="#images">Images</a></h1>
<p>Working with numbers and letters is fun, but it would be really cool to make visuals that wow our friends, and as always, there's a package for that!</p>
<p>In this chapter we're going to make images from our biological sequences!</p>
<h1 id="image-background"><a class="header" href="#image-background">Image Background</a></h1>
<p>A computer understands an image a little differently from us: in <a href="https://en.wikipedia.org/wiki/Pixel">pixels</a>! Pixels are the elemental building blocks of images, usually each comprised of three colors: red, green, and blue. Depending on the intensity of each color in the pixel, we can make any other color. For example, white would be 100% red, green, blue (RGB), where black would be 0% red, green, blue.</p>
<p><img src="Chapter_8/../img/magpix.jpg" alt="magnified pixels" /></p>
<p><em>Magnified pixels. If we squint, we can see that each 'pixel' is made of three rectangular stripes colored red, green, and blue in differing intensities. Image also from Wikipedia.</em></p>
<p>In the Rust Image library each pixel is represented by three values for RGB, respectively. Most conveniently, these are the same type of values we store for each letter of our sequence (<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">unsigned 8-bit integer</a>)! </p>
<h1 id="sequence-to-image"><a class="header" href="#sequence-to-image">Sequence To Image</a></h1>
<p>At it's heart, Rust doesn't care whether or data is biological or not and since we've already learned how to keep our data in an integer format, all we need to do to create an image from our sequences is to learn how to use the image library to make our first image!</p>
<p>In this example, we'll make each pixel a letter in our biological sequence, with a different color for each type of letter. If we applied this directly to a sequence, our image would be a single row of differing colored pixels. For example, AAACCC could be brownbrownbrowngreygreygrey. If we think of an image as a quilt or mat of numbers, we could have our image be multiple sequences. Each row of pixels would be a sequence and these would be written out to a file like a typewriter, row by row, to create our final image. Let's try it!</p>
<pre><code>// Import RgbImage from the Image crate
use image::RgbImage;

// Import colors from bioutils
use bioutils::utils::image::color::*;

// Set the width and height of our image. We'll make these constants (const) because they don't change for the whole program. 
const WIDTH: u32 = 50;
const HEIGHT: u32 = 50;

fn main() {
    // Make our sequence
    let seq = b&quot;AAAACCCCTTTTGGGGNNNN&quot;;

    // Make a new image with height and width that we'll put our data in
    let mut img = RgbImage::new(HEIGHT, WIDTH); 

    // Set our y coordinate to 49 for first example (the bottom row of pixels in our image) If we set to 50, it'll be out of bounds (0 to 49 for a height of 50) and rust will panic/error.
    
    let y_pixel_coord=49; 
    // Print our unsigned integers for reference
    println!(&quot;{:?}&quot;, seq); 

    // For each unsigned integer in our sequence 'c', color the pixel corresponding to the x coordinate and y coordinate, color by the unsigned integer present.
    for (x_pixel_coord, &amp;c) in seq.into_iter().enumerate() { 
        match c {
            67 =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, RED_RGB), // 67 is b&quot;A&quot;, set Adenosine color
            65 =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, GREEN_RGB), // 65 is b&quot;C&quot;, set Cytosine color
            84 =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, BLUE_RGB), // 84 is b&quot;T&quot;, set Thymine color
            71 =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, PURPLE_RGB), // 71 is b&quot;G&quot;, set Guanine color
            78 =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, GRAY_RGB), // 110 is b&quot;N&quot;, set Undetermined color
            _ =&gt; img.put_pixel(x_pixel_coord as u32, y_pixel_coord, BLACK_RGB), // set all other as black
        };
    }

    // write our image out to a file
    img.save(&quot;myfirstimage.png&quot;).unwrap();

}
</code></pre>
<p><img src="Chapter_8/../img/myfirstimage.png" alt="My First Image" /></p>
<p><em>Our very first image!</em></p>
<p>We've not only started working with images, we've even output it into a file we can send our friends!</p>
<h1 id="colored-image"><a class="header" href="#colored-image">Colored Image</a></h1>
<p>Our image has a single row of colored pixels, but we can fill the whole image with colors if we repeat the process for each row. Let's try it!</p>
<pre><code>use image::RgbImage;
use bioutils::utils::image::color::*;
const WIDTH: u32 = 50;
const HEIGHT: u32 = 50;

fn main() {
    
    // Create a new image

    let mut img = RgbImage::new(HEIGHT, WIDTH); 

    // Let's do the same thing with random sequences for the whole file

    for y in 0..HEIGHT {
        let rng = rand::thread_rng(); // Create a random number generator
        let dna = random_dna(50,rng); // Get a random dna sequence of length 50
        for (x, c) in dna.into_iter().enumerate() {
            match c {
                67 =&gt; img.put_pixel(x as u32, y, RED_RGB), // 67 is b&quot;A&quot;, set Adenosine color
                65 =&gt; img.put_pixel(x as u32, y, GREEN_RGB), // 65 is b&quot;C&quot;, set Cytosine color
                84 =&gt; img.put_pixel(x as u32, y, BLUE_RGB), // 84 is b&quot;T&quot;, set Thymine color
                71 =&gt; img.put_pixel(x as u32, y, CYAN_RGB), // 71 is b&quot;G&quot;, set Guanine color
                78 =&gt; img.put_pixel(x as u32, y, GRAY_RGB), // 110 is b&quot;N&quot;, set Undetermined color
                _ =&gt; img.put_pixel(x as u32, y, BLACK_RGB), // any other integer set to black
            };
        }
    }

    // write it out to a file
    img.save(&quot;mysecondimage.png&quot;).unwrap();
}
</code></pre>
<p>TADA!</p>
<p><img src="Chapter_8/../img/mysecondimage.png" alt="My Second Image" /></p>
<p><em>Our Second Image! A lot more color than our first!</em></p>
<h1 id="magnify-images"><a class="header" href="#magnify-images">Magnify Images</a></h1>
<p>We've made our images, but they seem a little small. We could make them bigger by changing the width and height constants of our whole image, but this would increase the size of the image but keep our sequence the same size. In this section, we'll magnify our image!</p>
<p><img src="Chapter_8/../img/squinting.png" alt="squinting" /></p>
<p><em>User trying to see our 10x10 pixel image</em></p>
<pre><code>fn main(){
https://docs.rs/image/0.23.14/image/imageops/fn.resize.html
}
</code></pre>
<h1 id="index"><a class="header" href="#index">Index</a></h1>
<p>This section of the book includes reference material such as tables, specifications, definitions, examples, and other material which is too bulky to fit into the main chapter pages of the book. Each chapter has it's own index.</p>
<h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous integration</a> (CI) is fancy terminology for automatically testing stuff when we publish code. If we could, we would run our code on a factory-fresh computer and document everything we did to have our code running. In continuous integration, we make a computer make a virtual computer doing exactly this. The virtual computer will be factory-fresh, and our continuous integration instructions will tell it to install prerequisites, move files, anything we need to have our code running. We then test to see if our code runs, and if it doesn't the code doesn't pass CI tests.</p>
<p>This is usually related to Git and version control, which can get pretty complicated and deserves it's own <a href="https://git-scm.com/book/en/">book</a>.</p>
<h1 id="endianness"><a class="header" href="#endianness">Endianness</a></h1>
<h2 id="what-big-endian-looks-like-from-u64"><a class="header" href="#what-big-endian-looks-like-from-u64">What big endian looks like from u64</a></h2>
<pre><code>use core::ops::Range;

fn main(){
    let x: u64 = 3;
    let y = x.to_be_bytes();
    println!(&quot;{:?}&quot;, y);
    
    // prints
} 
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=74327ba36eba7ac9f7bc45be23968379">playground</a></p>
<h1 id="index-ascii-code-table"><a class="header" href="#index-ascii-code-table">Index: ASCII Code Table</a></h1>
<p><em>Decimal number, hex number, binary, description, and character</em></p>
<pre><code>Dec	Hex	Binary	HTML	Char	Description
0	00	00000000	&amp;#0;	NUL	Null
1	01	00000001	&amp;#1;	SOH	Start of Header
2	02	00000010	&amp;#2;	STX	Start of Text
3	03	00000011	&amp;#3;	ETX	End of Text
4	04	00000100	&amp;#4;	EOT	End of Transmission
5	05	00000101	&amp;#5;	ENQ	Enquiry
6	06	00000110	&amp;#6;	ACK	Acknowledge
7	07	00000111	&amp;#7;	BEL	Bell
8	08	00001000	&amp;#8;	BS	Backspace
9	09	00001001	&amp;#9;	HT	Horizontal Tab
10	0A	00001010	&amp;#10;	LF	Line Feed
11	0B	00001011	&amp;#11;	VT	Vertical Tab
12	0C	00001100	&amp;#12;	FF	Form Feed
13	0D	00001101	&amp;#13;	CR	Carriage Return
14	0E	00001110	&amp;#14;	SO	Shift Out
15	0F	00001111	&amp;#15;	SI	Shift In
16	10	00010000	&amp;#16;	DLE	Data Link Escape
17	11	00010001	&amp;#17;	DC1	Device Control 1
18	12	00010010	&amp;#18;	DC2	Device Control 2
19	13	00010011	&amp;#19;	DC3	Device Control 3
20	14	00010100	&amp;#20;	DC4	Device Control 4
21	15	00010101	&amp;#21;	NAK	Negative Acknowledge
22	16	00010110	&amp;#22;	SYN	Synchronize
23	17	00010111	&amp;#23;	ETB	End of Transmission Block
24	18	00011000	&amp;#24;	CAN	Cancel
25	19	00011001	&amp;#25;	EM	End of Medium
26	1A	00011010	&amp;#26;	SUB	Substitute
27	1B	00011011	&amp;#27;	ESC	Escape
28	1C	00011100	&amp;#28;	FS	File Separator
29	1D	00011101	&amp;#29;	GS	Group Separator
30	1E	00011110	&amp;#30;	RS	Record Separator
31	1F	00011111	&amp;#31;	US	Unit Separator
32	20	00100000	&amp;#32;	space	Space
33	21	00100001	&amp;#33;	!	Exclamation mark
34	22	00100010	&amp;#34;	&quot;	Double quote
35	23	00100011	&amp;#35;	#	Number
36	24	00100100	&amp;#36;	$	Dollar sign
37	25	00100101	&amp;#37;	%	Percent
38	26	00100110	&amp;#38;	&amp;	Ampersand
39	27	00100111	&amp;#39;	'	Single quote
40	28	00101000	&amp;#40;	(	Left parenthesis
41	29	00101001	&amp;#41;	)	Right parenthesis
42	2A	00101010	&amp;#42;	*	Asterisk
43	2B	00101011	&amp;#43;	+	Plus
44	2C	00101100	&amp;#44;	,	Comma
45	2D	00101101	&amp;#45;	-	Minus
46	2E	00101110	&amp;#46;	.	Period
47	2F	00101111	&amp;#47;	/	Slash
48	30	00110000	&amp;#48;	0	Zero
49	31	00110001	&amp;#49;	1	One
50	32	00110010	&amp;#50;	2	Two
51	33	00110011	&amp;#51;	3	Three
52	34	00110100	&amp;#52;	4	Four
53	35	00110101	&amp;#53;	5	Five
54	36	00110110	&amp;#54;	6	Six
55	37	00110111	&amp;#55;	7	Seven
56	38	00111000	&amp;#56;	8	Eight
57	39	00111001	&amp;#57;	9	Nine
58	3A	00111010	&amp;#58;	:	Colon
59	3B	00111011	&amp;#59;	;	Semicolon
60	3C	00111100	&amp;#60;	&lt;	Less than
61	3D	00111101	&amp;#61;	=	Equality sign
62	3E	00111110	&amp;#62;	&gt;	Greater than
63	3F	00111111	&amp;#63;	?	Question mark
64	40	01000000	&amp;#64;	@	At sign
65	41	01000001	&amp;#65;	A	Capital A
66	42	01000010	&amp;#66;	B	Capital B
67	43	01000011	&amp;#67;	C	Capital C
68	44	01000100	&amp;#68;	D	Capital D
69	45	01000101	&amp;#69;	E	Capital E
70	46	01000110	&amp;#70;	F	Capital F
71	47	01000111	&amp;#71;	G	Capital G
72	48	01001000	&amp;#72;	H	Capital H
73	49	01001001	&amp;#73;	I	Capital I
74	4A	01001010	&amp;#74;	J	Capital J
75	4B	01001011	&amp;#75;	K	Capital K
76	4C	01001100	&amp;#76;	L	Capital L
77	4D	01001101	&amp;#77;	M	Capital M
78	4E	01001110	&amp;#78;	N	Capital N
79	4F	01001111	&amp;#79;	O	Capital O
80	50	01010000	&amp;#80;	P	Capital P
81	51	01010001	&amp;#81;	Q	Capital Q
82	52	01010010	&amp;#82;	R	Capital R
83	53	01010011	&amp;#83;	S	Capital S
84	54	01010100	&amp;#84;	T	Capital T
85	55	01010101	&amp;#85;	U	Capital U
86	56	01010110	&amp;#86;	V	Capital V
87	57	01010111	&amp;#87;	W	Capital W
88	58	01011000	&amp;#88;	X	Capital X
89	59	01011001	&amp;#89;	Y	Capital Y
90	5A	01011010	&amp;#90;	Z	Capital Z
91	5B	01011011	&amp;#91;	[	Left square bracket
92	5C	01011100	&amp;#92;	\	Backslash
93	5D	01011101	&amp;#93;	]	Right square bracket
94	5E	01011110	&amp;#94;	^	Caret / circumflex
95	5F	01011111	&amp;#95;	_	Underscore
96	60	01100000	&amp;#96;	`	Grave / accent
97	61	01100001	&amp;#97;	a	Small a
98	62	01100010	&amp;#98;	b	Small b
99	63	01100011	&amp;#99;	c	Small c
100	64	01100100	&amp;#100;	d	Small d
101	65	01100101	&amp;#101;	e	Small e
102	66	01100110	&amp;#102;	f	Small f
103	67	01100111	&amp;#103;	g	Small g
104	68	01101000	&amp;#104;	h	Small h
105	69	01101001	&amp;#105;	i	Small i
106	6A	01101010	&amp;#106;	j	Small j
107	6B	01101011	&amp;#107;	k	Small k
108	6C	01101100	&amp;#108;	l	Small l
109	6D	01101101	&amp;#109;	m	Small m
110	6E	01101110	&amp;#110;	n	Small n
111	6F	01101111	&amp;#111;	o	Small o
112	70	01110000	&amp;#112;	p	Small p
113	71	01110001	&amp;#113;	q	Small q
114	72	01110010	&amp;#114;	r	Small r
115	73	01110011	&amp;#115;	s	Small s
116	74	01110100	&amp;#116;	t	Small t
117	75	01110101	&amp;#117;	u	Small u
118	76	01110110	&amp;#118;	v	Small v
119	77	01110111	&amp;#119;	w	Small w
120	78	01111000	&amp;#120;	x	Small x
121	79	01111001	&amp;#121;	y	Small y
122	7A	01111010	&amp;#122;	z	Small z
123	7B	01111011	&amp;#123;	{	Left curly bracket
124	7C	01111100	&amp;#124;	|	Vertical bar
125	7D	01111101	&amp;#125;	}	Right curly bracket
126	7E	01111110	&amp;#126;	~	Tilde
127	7F	01111111	&amp;#127;	DEL	Delete
</code></pre>
<h1 id="semicolons"><a class="header" href="#semicolons">Semicolons</a></h1>
<p>What's the point of the semicolons? Aren't we just typing a new thing we want to do on a new line anyway? In Python and R, we continue what we're doing by going to a new line.</p>
<p>In Rust, semicolons separate the steps of a function. This means we could just type everything on one line separated by semicolons, even though this would look kind of weird. Going to a new line isn't necessary, but makes it look nicer like in Python and R.</p>
<p>In Rust, the whole binary is run like a single function, thus the main function structure. This means that if we don't have a semicolon, we'll return whatever we get from the non-semicolon line, the main function will end, and so will our program. If we want to return something from a function, we don't need to type <code>return</code>, we just leave out a semicolon!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
